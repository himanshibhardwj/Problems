class Solution {
    public int maxRectSum(int mat[][]) {
    int n = mat.length;
    if (n == 0) return 0;
    int m = mat[0].length; 
    int maxSum = Integer.MIN_VALUE;
    int[] temp = new int[n];
    for (int left = 0; left < m; left++) {
     
        Arrays.fill(temp, 0);

        for (int right = left; right < m; right++) {
           
            for (int i = 0; i < n; i++) {
                temp[i] += mat[i][right];
            }
            int currMax = temp[0];
            int currSum = temp[0];
            for (int i = 1; i < n; i++) {
                currSum = Math.max(temp[i], currSum + temp[i]);
                currMax = Math.max(currMax, currSum);
            }
            maxSum = Math.max(maxSum, currMax);
        }
    }
    return maxSum;
}  
};





int n = mat.length;
    if (n == 0) return 0;
    int m = mat[0].length; 
//n = number of rows, m = number of columns
Return 0 if the matrix is empty.


temp[] will temporarily hold the sum of elements between two columns (left and right) for each row.



for (int left = 0; left < m; left++) {
You fix the left column.
Then, for every right column from left to m - 1, you will:
Add up elements from column left to right for every row and store the result in temp[].




 for (int i = 1; i < n; i++) {
                currSum = Math.max(temp[i], currSum + temp[i]);
                currMax = Math.max(currMax, currSum);
then  
maximum sum subarray in temp[], which corresponds to the best set of consecutive rows for current left and right columns.





Time Complexity
O(mÂ² * n):

m * m for all column pairs (left, right)

n for each Kadane's application


